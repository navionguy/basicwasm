package keybuffer

import (
	"errors"
	"time"

	"github.com/navionguy/basicwasm/ast"
)

type KeyBuffer struct {
	KeySettings *ast.KeySettings
	keycodes    chan ([]byte)
	inp         []byte
	ind         int
	sig_break   bool
}

var kbuff KeyBuffer

func GetKeyBuffer() *KeyBuffer {
	return &kbuff
}

// SaveKeyStroke saves all the bytes generated by a keystroke
func (buff *KeyBuffer) SaveKeyStroke(key []byte) {
	// check if my channel has been created
	if buff.keycodes == nil {
		// create a buffered channel
		buff.keycodes = make(chan []byte, 20)
	}

	// check for an empty array
	if len(key) == 0 {
		return
	}

	// write array to the channel
	buff.keycodes <- key
	// ctrl-c means user wants to stop execution
	buff.checkForCtrlC(key)
}

// checkForCtrlC - looks to flag the user entered a ctrl-c
func (buff *KeyBuffer) checkForCtrlC(inp []byte) {
	for _, k := range inp {
		if k == 0x03 {
			buff.sig_break = true
		}
	}
}

// has a Ctrl-C been entered
func (buff *KeyBuffer) BreakSeen() bool {
	time.Sleep(15 * time.Millisecond)
	return buff.sig_break
}

// reset the break flag
func (buff *KeyBuffer) ClearBreak() {
	buff.sig_break = false
}

// ReadByte returns the next byte, caller has to decide if he needs more
func (buff *KeyBuffer) ReadByte() (byte, error) {
	// if I'm working a byte array keep going
	if (buff.inp != nil) && (buff.ind < len(buff.inp)) {
		t := buff.ind
		buff.ind++
		return buff.inp[t], nil
	}

	// if the channel doesn't exist, nothing to report
	if buff.keycodes == nil {
		return ' ', errors.New("no data")
	}

	// try to read key scan codes and repor it
	select {
	case buff.inp = <-buff.keycodes:
		buff.ind = 1
		return buff.inp[0], nil
	default:
		// nothing to report
		return ' ', errors.New("no data")
	}
}
