package keybuffer

import "time"

var buffer []byte
var read int
var write int
var ringsize int
var sig_break bool

func init() {
	read = 0
	write = 0
	ringsize = 300
	buffer = make([]byte, ringsize)
}

// SaveKeyStroke saves all the bytes generated by a keystroke
func SaveKeyStroke(key []byte) {
	tw := write
	for _, bt := range key {
		// ctrl-c means user wants to stop execution
		checkForCtrlC(bt)

		buffer[tw] = bt
		tw++
		if tw == ringsize {
			// wrap back to the beginning
			tw = 0
		}
		if tw == read {
			//I've filled the buffer!
			return
		}
	}
	write = tw
}

// checkForCtrlC - looks to flag the user entered a ctrl-c
func checkForCtrlC(c byte) {
	if c == 0x03 {
		sig_break = true
	}
}

// has a Ctrl-C been entered
func BreakSeen() bool {
	time.Sleep(15 * time.Millisecond)
	return sig_break
}

// reset the break flag
func ClearBreak() {
	sig_break = false
}

// ReadByte returns the next byte, caller has to decide if he needs more
func ReadByte() (byte, bool) {
	if read == write {
		return ' ', false
	}
	bt := buffer[read]
	read++
	if read == ringsize {
		read = 0
	}
	return bt, true
}

func size() int {
	if write >= read {
		return write - read
	}

	// writing has wrapped around, reading has not
	return write + ringsize - read
}
